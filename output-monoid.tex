\section{The regular functions}
\label{sec:reg-char}
The two straightforward constructions in Theorems~\ref{thm:all-functions} and~\ref{thm:reco-reflecting-functions}  amount to little more than symbol pushing. In this section, we present a more substantial characterization, which is the main result of this paper.
% In this characterization, we use functors that are finiteness-preserving.
This characterization concerns finiteness-preserving functors.
% (above rephrased mainly to avoid vertical alignment of two occurrences of "finiteness-preserving")
This is a strengthening of the condition from Theorem~\ref{thm:reco-reflecting-functions}: if the functor $\functor$ in a transducer semigroup is finiteness-preserving, then for every finite semigroup $A$, the output function $\functor A \to A$ will be recognizable, since all functions from a finite semigroup are trivially recognizable.  However, the condition is strictly stronger, as witnessed by Example~\ref{ex:squaring}, which is recognizability reflecting (cf.~\Cref{ex:squaring-reco-refl}) but not finiteness preserving. As we will see, the stronger condition will characterize exactly the regular string-to-string functions.

The following counterexample illustrates the non-trivial interaction between naturality of the output mechanism interacts and the requirement that 
the functor is finiteness preserving.

\begin{example}
    Consider the powerset functor $\powerset$ from Example~\ref{ex:functors}. It is finiteness-preserving, since the powerset of a finite semigroup is also finite. One could imagine that using powersets, one could construct a transducer semigroup that recognizes functions that are not regular, e.g.~because they have exponential growth (unlike regular functions, which have linear growth). It turns out that this is impossible, because there is no possible output mechanism, i.e.~no natural transformation of type $\powerset A \to A$, as we explain below.

    The issue is that the naturality condition disallows choosing elements from a subset.  To see why, consider a semigroup $A$ with two elements, with the trivial left zero semigroup structure. For this semigroup, the output mechanism of type $\powerset A \to A$ would need to choose some element $a \in A$ when given as input the full set $A \in \powerset A$. However, none of the two choices is right, because swapping the two elements of $A$ is an automorphism of the semigroup $A$, which maps the full set to itself, but does not map any element to itself.
\end{example}

We now state the main theorem of this paper. 
% Unlike the previous characterizations, it concerns the functions from a free monoid $\Sigma^*$ over a finite alphabet to a semigroup $A$, because the models defining regular functions operate on strings, and not on abstract semigroups. Some of the models, such as streaming string transducers (\sst) or two-way automata, easily make sense when the output is an abstract semigroup, but the string structure of the input seems to be essential for all the models. 

% Among the functors described in Example~\ref{ex:functors},  ``reverse'' and ``powerset''  are finiteness preserving, in the sense that if they are applied to a finite semigroup, then the result is also a finite semigroup. The ``tuple'' functor $A^n$ is finiteness preserving if and only if the exponent $n$ is finite. The ``list'' functor $A^+$ is not finiteness preserving. 

\begin{theorem}\label{thm:regular-functions}
    The following conditions are equivalent for every string-to-string function:
    \begin{enumerate}
        \item \label{it:regular} it is a regular string-to-string function;
        \item \label{it:trans-semig-regular}it is recognized by a transducer semigroup  in which the functor is finiteness preserving. 
    \end{enumerate}
\end{theorem}

\noindent Here is the plan for the rest of this section:
\begin{description}
    \item[Section~\ref{sec:sst-definition}] gives a formal definition of regular functions
    \item[Section~\ref{sec:easy}] proves the easy  implication in the theorem, namely  $(\ref{it:regular}) \Rightarrow (\ref{it:trans-semig-regular})$
    \item[Section~\ref{sec:hard}] proves the hard  implication in the theorem, namely  $(\ref{it:regular}) \Leftarrow (\ref{it:trans-semig-regular})$
\end{description}

Before continuing, we remark on one advantage of the characterization, namely a
straightforward proof of closure under composition. In contrast, for some (but
not all) existing models defining regular string-to-string functions,
composition requires a non-trivial construction -- examples include two-way
transducers~\cite[Theorem 2]{ChytilJ77} or copyless \sst~\cite[Theorem
1]{composingSST}.
\begin{proposition}\label{prop:composition}
  Functions recognized by finiteness-preserving transducer semigroups are closed
  under composition.
\end{proposition}
\begin{proof}
  This is because finiteness-preserving functors are closed under composition,
  natural output functions are also closed under composition, and naturality
  means by definition that the output functions \enquote{commute} in a suitable
  sense with functors.\footnote{More precisely, consider the following diagram,
    where the upper path describes the composition of two functions recognized
    transducer semigroups $(\functor,\outfun)$ and $(\functor',\outfun')$,
    respectively:
    \[
      \begin{tikzcd}[ampersand replacement=\&, column sep=2cm]
        \Sigma^* 
        \ar[r,"h"]
        \& 
        \functor(\Gamma^*)
        \ar[r,"\outfun_{\Gamma^*}"]
        \ar[d,"\functor h'"]
        \&
        \Gamma^* \ar[d,"h'"]\\
        \&
        \functor\functor'(\Pi^*) \ar[r,"\outfun_{\functor'(\Pi^*)}"]
        \& 
        \functor'(\Pi^*)
        \ar[r,"\outfun'_{(\Pi^*)}"]
        \&
        \Pi^*
      \end{tikzcd}
    \]
    The rectangle in the middle commutes by naturality, and therefore the upper path is equal to the lower path. The latter describes a function recognized by $(\functor\functor', \outfun_{\functor'(-)} \circ \outfun')$.}
\end{proof}



 
\input{easy}

\input{polynomial-functors}

\subparagraph{Factorized output.}
Now, consider some transducer semigroup, with the functor being $\functor$, and fix a string-to-semigroup function $f\colon \Sigma^* \to A$ that decomposes as some homomorphism $h\colon \Sigma^* \to \functor A$ followed by the output function of type $\functor A \to A$. 

For semigroups $A_1,\ldots,A_n$, define the \emph{vectorial output function} to be the 
function% of type 
\begin{align*}
\qquad\functor A_1 \times \cdots \times \functor A_n \longrightarrow A_1 \oplus \cdots \oplus A_n
\end{align*}
that is obtained by composing the three functions described below
\[
\begin{tikzcd}
\functor A_1 \times \cdots \times \functor A_n
\ar[d,"\functor(\text{co-projection}) \times \cdots \times \functor(\text{co-projection})"]
\\
\functor(A_1 \oplus \cdots \oplus A_n)
\times
\cdots
\times 
\functor(A_1 \oplus \cdots \oplus A_n)
\ar[d,"\text{semigroup operation}"]
\\
\functor(A_1 \oplus \cdots \oplus A_n)
\ar[d, "\text{output mechanism for $A_1 \oplus \cdots \oplus A_n$}"]\\ 
A_1 \oplus \cdots \oplus A_n.
\end{tikzcd}
\]

    To illustrate the definitions in this section, we use a running example with the transducer semigroup  from \Cref{ex:duplicator} for the duplicating function. The functor is the identity $\functor A = A$, and the output mechanism is $a \mapsto aa$. The duplicating function on $\set{a,b}^*$ is obtained by composing the identity homomorphism on $\set{a,b}^* = 
\functor(\set{a,b}^*)$
    with the output function.
    Here is an example of  the vectorial output function, applied to $A_1=1$ and $A_2=\set{a,b}^*$:
\begin{align*}
    (1,abbb) \in \functor 1 \times \functor \set{a,b}^* \qquad \mapsto \qquad 
\red{\boxed{1}}\  \boxed{abbb} \ \red{\boxed{1}} \  \boxed{abbb} \in 1 \oplus \set{a,b}^*.
\end{align*}
The  vectorial output function is natural in all of its arguments, which means that  
\[
\begin{tikzcd}
    [column sep=4cm]
\functor A_1 \times \cdots \times \functor A_n
\ar[r,"\text{vectorial output function}"]
\ar[d,"\functor h_1 \times \cdots \times \functor h_n"']
&
A_1 \oplus \cdots \oplus A_n
\ar[d,"h_1 \oplus \cdots \oplus h_n"]
\\
\functor B_1 \times \cdots \times \functor B_n
\ar[r,"\text{vectorial output function}"]
&
B_1 \oplus \cdots \oplus B_n
\end{tikzcd}
\]
commutes
for all semigroup homomorphisms $h_1,\ldots,h_n$. This is because each of the three steps in the definition of the vectorial output function is itself a natural transformation, and natural transformations compose.  Naturality of the first two steps is easy to check, while for the last step we use the assumption that the (non-vectorial) output function is natural.
% In other words, the factorized output function is a natural 
% transformation of type 
% \[\begin{tikzcd}
%     [column sep=1cm]
%     {\text{Semigroups}^n} && {\text{Sets}}
%     \arrow[""{name=0, anchor=center}, "{(A_1,\ldots,A_n)} \mapsto \text{underlying set of } \functor A_1 \times \cdots \times \functor A_n", curve={height=-18pt}, from=1-1, to=1-3]
%     \arrow[""{name=1, anchor=center, inner sep=0}, "{(A_1,\ldots,A_n)} \mapsto \text{underlying set of } A_1 \oplus \cdots \oplus A_n"', curve={height=18pt}, from=1-1, to=1-3]
%     \arrow[ shorten <=5pt, shorten >=5pt, Rightarrow, from=0, to=1]
% \end{tikzcd}\]



% By abuse of notation, we allow some -- but not all -- of the arguments in the factorized output to be empty; in this case the empty arguments are ignored, but the output type is still a co-product of $n$ semigroups. For example, if the input to the factorized output function is 
% \begin{align*}
% (1, \varepsilon) \in 1 \oplus \set{a,b}^+
% \end{align*}
% then the factorized  output is  
% \begin{align*}
% 1 1     \in 1 \oplus \set{a,b}^+.
% \end{align*}

Let us return to our function $f = \outfun_A \circ h$ recognized by our transducer semigroup $(\functor,\outfun)$.
%Using the vectorial output mechanism, we will be able to track the origins in the output of the function $f$, with respect to some partition of the input string into several nonempty parts.
For strings $w_1,\ldots,w_n \in \Sigma^*$, define the corresponding \emph{factorized output} to be the result of first applying the semigroup homomorphism $h : \Sigma^* \to \functor A$ to all the strings, and then applying the vectorial output function; we denote it by 
\begin{align*}
\tuple{w_1| \cdots | w_n} \in \myunderbrace{A \oplus \cdots \oplus A}{$n$ times},
\end{align*}
Here is the factorized output illustrated in our running example (we use colours to distinguish which of the three parts of the input is used):
\begin{align*}
        \tuple{\red{abb} | \varepsilon | \blue{bbaba}} =  
        \red{\boxed{abb}} \ 
        \boxed{\varepsilon} \ 
        \blue{\boxed{bbaba}} \ 
        \red{\boxed{abb}} \ 
        \boxed{\varepsilon} \
        \blue{\boxed{bbaba}} \in \red{\set{a,b}^*} \oplus \set{a,b}^*  \oplus \blue{\set{a,b}^*}.
\end{align*}
As we can see above, when the output semigroup is a free monoid, the factorized output morally tells us \enquote{which part of the output string comes from which part in the input string}.
\begin{remark}
This is similar to the idea of \emph{origin semantics}~\cite{bojanczykTransducersOriginInformation2014} of regular functions (see also~\cite[Section~5]{MuschollPuppis}). Indeed, our definition of factorized output is inspired by a similar tool of the same name that appears in the study of origin semantics~\cite[Section~2]{bojanczykTransducersOriginInformation2014}.
\end{remark}

We also use a similar notation but with some input strings underlined, e.g.~the input could be $\tuple{\red{\underline{abb}} | \varepsilon | \blue{bbaba}}$ with an underline for the first red part. In the underlined case, before applying the vectorial output function, we apply $h$ to the non-underlined strings and
% \[
% \begin{tikzcd}
% \Sigma^*
% \ar[r,"h"]
% &
% \functor A 
% \ar[r,"\functor !"]
% &
% \functor 1.
% \end{tikzcd}
% \]
$(\functor! \circ h) \colon \Sigma^* \to \functor1$
to the underlined strings. In our running example, we have
    \begin{align*}
        \tuple{\red{\underline{abb}} | \varepsilon | \blue{bbaba}} =  
        \red{\boxed{1}} \ 
        \boxed{\varepsilon} \
        \blue{\boxed{bbaba}} \ 
        \red{\boxed{1}} \ 
        \boxed{\varepsilon} \
        \blue{\boxed{bbaba}}.
        \end{align*}

\subparagraph*{Proof of $(\ref{it:trans-semig-regular}) \Rightarrow (\ref{it:regular})$ in \Cref{thm:regular-functions}.}
We have now collected all necessary ingredients to prove this hard direction of
the equivalence. Therefore, our goal is now to show that the function $f\colon
\Sigma^* \to A$ that we have previously fixed is computed by some functorial
streaming string transducer as in Definition~\ref{def:functorial-sst}.
We will see that this can be done merely assuming that \emph{$\functor 1$ is finite} -- a particular instance of the assumption in (\ref{it:trans-semig-regular}) that $\functor$ is finiteness-preserving.

The idea is that we want the \sst to maintain the following invariant: \emph{after processing the first $i$ letters in an input string $a_1 \cdots a_n$, the register valuation is equal to the factorized output $\tuple{a_1 \cdots a_i | \underline{a_{i+1} \cdots a_n}}$}. This way, after processing all input letters, the last valuation $\tuple{a_1 \cdots a_n | \underline{\varepsilon}}$ is very close to the output $f(a_1\dots a_n) = \tuple{a_1 \dots a_n} \in A = \text{1-ary coproduct}$.

The naive choice for the register functor is then $\functorr' : A \mapsto A \oplus 1$, since $\tuple{w|\underline{v}} \in A\oplus1$ for all $w,v\in\Sigma^*$ by definition. However, while $\functorr'$ can be seen as a polynomial semigroup-to-set functor, whose components are indexed by $1 \oplus 1$ (cf.~\Cref{rem:coproduct-as-polynomial-functor}), it is not \emph{finite} polynomial (the set $1\oplus1$ is infinite). That said, we have by naturality (cf.~appendix) that:
\begin{claim}
  The component index for $\tuple{w|\underline{v}} \in \functorr'A$ is $\tuple{\underline{w}|\underline{v}} \in 1 \oplus 1$.
\end{claim}
This index is determined by definition by the values of $(\functor! \circ h) \colon \Sigma^* \to \functor1$ on $w$ and $v$. \emph{Since $\functor1$ is finite,} the $\tuple{w|\underline{v}}$ for $w,v$ ranging over $\Sigma^*$ live in finitely many components. We take our register functor  $\functorr A \subset \functorr' A$ to be the finite polynomial functor consisting of these \enquote{useful} components, plus the unique component that does not use $A$ (it will serve as a \enquote{null value}).

To design the register updates, the key is the following lemma. It shall be proved later using the machinery of views on coproducts that we have introduced for this very purpose.
\begin{lemma}\label{lem:compute-next-configuration}
  There is a {copyless} natural function
  \[
    \delta\colon (A \oplus 1) \times (1 \oplus A \oplus 1) \to A \oplus 1
    \qquad\text{such that}\qquad
    \tuple{wa|\underline v} = \delta(\tuple{w|\underline {av}},\tuple{\underline w | a|\underline v})
  \]
  for every pair of strings $w,v \in \Sigma^*$ and every letter $a \in \Sigma$.
\end{lemma}
This leads us to use the update functor $\functoru : A \mapsto 1 \oplus A \oplus 1$ and to define the application of updates to registers, of type $\functorr A \times (1 \oplus A \oplus 1) \to \functorr A$, to be $\delta$ followed by the map $A \oplus 1 \to \functorr A$ which sends the components in $\functorr A$ to themselves and the rest to the \enquote{null value}.
As an immediate consequence of the lemma, the desired invariant holds if we use
\begin{itemize}
  \item the initial function $w \mapsto \tuple{\varepsilon|\underline{w}}$,
  \item and the update oracle $a_1 \dots a_n \mapsto \tuple{\underline\varepsilon|a_1|\underline{a_2 \dots a_n}} \dots
  \tuple{\underline{a_1 \dots a_{n-1}}|a_n|\underline\varepsilon}$.
\end{itemize}
To fit \Cref{def:functorial-sst}, we have to check that the initial function is recognizable and that the update oracle is a rational function; by definition, the latter amounts to saying that for any $a\in\Sigma$, the function $(w,v) \in (\Sigma^*)^2 \mapsto \tuple{\underline{w}|a|\underline{v}}$ is recognizable. According to the definition of factorized output, the initial function factors through the semigroup homomorphism $\functor! \circ h$, \emph{whose codomain $\functor1$ is finite,} therefore the initial function is recognizable. The other recognizability condition holds for a similar reason.

What remains is to define a way to turn the last register valuation
$\tuple{w|\underline\varepsilon}$ into the output $\tuple{w} = f(w)$ for any input string
$w$, and to prove \Cref{lem:compute-next-configuration}. For both of these
goals, it is useful to consider a sort of left inverse to the \emph{deconstruction} into views and shape of \Cref{lem:views} -- that is, a \emph{reconstruction} function of type
\[ (1 \oplus A_1) \times \cdots \times (1 \oplus A_n) \times (1 \oplus \cdots
  \oplus 1) \longrightarrow (A_1 \oplus \cdots \oplus A_n) + \myunderbrace{1}{default value when the input is not in the image of the deconstruction\qquad\qquad\qquad\qquad\qquad\qquad} \]
such that deconstruction followed by reconstruction maps every element of $A_1 \oplus \cdots \oplus A_n$ to itself. The injectivity proof in \Cref{lem:views} actually provides such a reconstruction function.
And in the case of a binary coproduct $A \oplus A$, any of the two views determines the shape, so we have a binary reconstruction of type $(A\oplus1)\times(1\oplus A) \to (A\oplus A)+1$.

To finish building our functorial \sst, let our final functor be $\functork : A \mapsto (1 \oplus A)\times A$, our final value function be $w\in\Sigma^* \mapsto (\tuple{\underline{w}|\varepsilon},\;\text{some arbitrary fixed value in}\ A)$ -- it is recognizable because $\functor1$ is finite, again -- and our final output function $\functorr A \times \functork A \to A$ be defined as follows: apply binary reconstruction to get some value in $((A\oplus A)+1)\times A$; if the left component is in $A\oplus A$, merge it to produce an output in $A$; otherwise, return the right component. One can check that this output function applied to $\tuple{w|\underline\varepsilon}$ and $(\tuple{\underline{w}|\varepsilon},\;\text{anything})$ returns $\tuple{w}$ -- this is similar to \Cref{claim:merge-factorized-output} below -- so that our functorial \sst indeed computes $f$.

This being done, let us discharge our only remaining subgoal.

\begin{proof}[Proof of \Cref{lem:compute-next-configuration}]
    We use the following claim, which is proved using naturality of the output mechanism (as detailed in the appendix).
    \begin{claim}\label{claim:merge-factorized-output}
        $\tuple{wa|\underline v}$ is obtained from $\tuple{w|a|\underline v}$ by merging the first two parts.
    \end{claim}
    % \begin{proof}[Proof sketch]
    %     % The following diagram commutes 
    %     % \[
    %     % \begin{tikzcd}
    %     %     [column sep=3cm]
    %     % \Sigma^* \times \Sigma \times \Sigma^* 
    %     % \ar[r,"{(w,a,v) \mapsto \tuple{w|a|\underline v}}"]
    %     % \ar[d,"{(w,a,v) \mapsto (wa,v)}"']
    %     % &
    %     % A \oplus A \oplus 1
    %     % \ar[d,"\text{merge first two coordinates}"]
    %     % \\
    %     % \Sigma^+ \times \Sigma^* 
    %     % \ar[r,"{(wa,v) \mapsto \tuple{wa|\underline v}}"']
    %     % &
    %     % A  \oplus 1
    %     % \end{tikzcd}
    %     % \]
    %  Using naturality of the output mechanism, and $\outfun$ and the fact that  both $h$ and merging the first two \enquote{copies of $A$} in $A \oplus A \oplus 1$ (by copairing coprojections) are homomorphisms.
    % \end{proof}

    Since merging the first two parts is a copyless natural function,  the above
    claim shows that  the factorized output $\tuple{wa|\underline v}$ is
    obtained from $\tuple{w|a|\underline v}$ by a copyless natural function.
    In turn, $\tuple{w|a|\underline v}$ can be obtained by applying the reconstruction function to the following four items (the equalities below are proved analogously to Claim~\ref{claim:merge-factorized-output}):
     \begin{enumerate}
        \item \label{it:first-view}First view of $\tuple{w|a|\underline v}$, which is equal to $\tuple{w|\underline {av}}$ -- this is the first argument of the function $\delta$ that we want to define.
        \item  \label{it:second-view} Second view of $\tuple{w|a|\underline v}$, which is obtained by merging the first and third parts in $\tuple{\underline w|a|\underline v}$.
        \item \label{it:third-view}   Third view of $\tuple{w|a|\underline v}$, which is equal to $\tuple{\underline {wa}|\underline{v}}$.
        \item   \label{it:shape} Shape of~$\tuple{w|a|\underline v}$, which is equal to $\tuple{\underline w|\underline a| \underline v}$.
     \end{enumerate}
     (Strictly speaking, this reconstruction returns an element of $(1 \oplus A \oplus 1)+1$, and we should postcompose it by a map $(1 \oplus A \oplus 1)+1 \to 1 \oplus A \oplus 1$ that sends the right summand $1$ to some default value that does not use $A$.)
     
     To complete the proof of the lemma, it remains to justify that the last three items in the above enumeration can be collectively obtained from the second argument of $\delta$, namely $\tuple{\underline w|a|\underline v}$, by applying some copyless natural function. Each item is obtained separately by applying a natural function. Furthermore, the second item is obtained in a copyless way, while the last two items do not use $A$ at all, and therefore they are obtained in a copyless way for trivial reasons, even when combined with the second item.
\end{proof}


% \begin{lemma}
%     There is a letter-to-letter rational function 
%     \begin{align*}
%     \rho : \Sigma^* \to (1 \oplus A \oplus 1)^*
%     \end{align*}
%     such that for every input string $a_1 \cdots a_n$, the $i$-th letter of the output is 
%     \begin{align*}
%         \tuple{\underline{a_1 \cdots a_{i-1}}|a_i| \underline{ a_{i+1} \cdots a_n}} \in 1 \oplus A \oplus 1.
%     \end{align*}
% \end{lemma}
% \begin{proof}
%     For an interval $\set{i,\ldots,j}\subseteq \set{1,\ldots,n}$, we define 
%     The $i$-th letter produced by the rational function is 
%     \begin{align*}
%         \tuple{\underline{a_1 \cdots a_{i-1}}|a_i| \underline{ a_{i+1} \cdots a_n}} \in 1 \oplus A \oplus 1.
%     \end{align*}
% We begin by showing that these letters can indeed be produced by a letter-to-letter rational function. To see this, we observe that the above depends only on the letter $a_i$, as well as the images of the strings $a_1 \cdots a_{i-1}$ and $a_{i+1} \cdots a_n$ under the semigroup homomorphism
% \begin{align*}
% \functor ! : \Sigma^* \to \functor 1.
% \end{align*}
% Since the target of this homomorphism is a finite semigroup, by the assumption that the functor is finiteness preserving, it follows that the 
% \end{proof}
