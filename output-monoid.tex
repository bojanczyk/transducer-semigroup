\section{The regular functions}
\label{sec:reg-char}
The two straightforward constructions in Theorems~\ref{thm:all-functions} and~\ref{thm:reco-reflecting-functions}  amount to little more than symbol pushing. In this section, we present a more substantial characterization, which is the main result of this paper.
% In this characterization, we use functors that are finiteness-preserving.
This characterization concerns finiteness-preserving functors.
% (above rephrased mainly to avoid vertical alignment of two occurrences of "finiteness-preserving")
This is a strengthening of the condition from Theorem~\ref{thm:reco-reflecting-functions}: if the functor $\functor$ in a transducer semigroup is finiteness-preserving, then for every finite semigroup $A$, the output function $\functor A \to A$ will be recognizable, since all functions from a finite semigroup are trivially recognizable.  However, the condition is strictly stronger, as witnessed by Example~\ref{ex:squaring}, which is recognizability reflecting (cf.~\Cref{ex:squaring-reco-refl}) but not finiteness preserving. As we will see, the stronger condition will characterize exactly the regular string-to-string functions.

The following counterexample illustrates the non-trivial interaction between naturality of the output mechanism interacts and the requirement that 
the functor is finiteness preserving.

\begin{example}
    Consider the powerset functor $\powerset$ from Example~\ref{ex:functors}. It is finiteness-preserving, since the powerset of a finite semigroup is also finite. One could imagine that using powersets, one could construct a transducer semigroup that recognizes functions that are not regular, e.g.~because they have exponential growth (unlike regular functions, which have linear growth). It turns out that this is impossible, because there is no possible output mechanism, i.e.~no natural transformation of type $\powerset A \to A$, as we explain below.

    The issue is that the naturality condition disallows choosing elements from a subset.  To see why, consider a semigroup $A$ with two elements, with the trivial left zero semigroup structure. For this semigroup, the output mechanism of type $\powerset A \to A$ would need to choose some element $a \in A$ when given as input the full set $A \in \powerset A$. However, none of the two choices is right, because swapping the two elements of $A$ is an automorphism of the semigroup $A$, which maps the full set to itself, but does not map any element to itself.
\end{example}

We now state the main theorem of this paper. 
% Unlike the previous characterizations, it concerns the functions from a free monoid $\Sigma^*$ over a finite alphabet to a semigroup $A$, because the models defining regular functions operate on strings, and not on abstract semigroups. Some of the models, such as streaming string transducers (\sst) or two-way automata, easily make sense when the output is an abstract semigroup, but the string structure of the input seems to be essential for all the models. 

% Among the functors described in Example~\ref{ex:functors},  ``reverse'' and ``powerset''  are finiteness preserving, in the sense that if they are applied to a finite semigroup, then the result is also a finite semigroup. The ``tuple'' functor $A^n$ is finiteness preserving if and only if the exponent $n$ is finite. The ``list'' functor $A^+$ is not finiteness preserving. 

\begin{theorem}\label{thm:regular-functions}
    The following conditions are equivalent for every string-to-string function:
    \begin{enumerate}
        \item \label{it:regular} it is a regular string-to-string function;
        \item \label{it:trans-semig-regular}it is recognized by a transducer semigroup  in which the functor is finiteness preserving. 
    \end{enumerate}
\end{theorem}

\noindent Here is the plan for the rest of this section:
\begin{description}
    \item[Section~\ref{sec:sst-definition}] gives a formal definition of regular functions
    \item[Section~\ref{sec:easy}] proves the easy  implication in the theorem, namely  $(\ref{it:regular}) \Rightarrow (\ref{it:trans-semig-regular})$
    \item[Section~\ref{sec:hard}] proves the hard  implication in the theorem, namely  $(\ref{it:regular}) \Leftarrow (\ref{it:trans-semig-regular})$
\end{description}

Before continuing, we remark on one advantage of the characterization, namely a
straightforward proof of closure under composition. In contrast, for some (but
not all) existing models defining regular string-to-string functions,
composition requires a non-trivial construction -- examples include two-way
transducers~\cite[Theorem 2]{ChytilJ77} or copyless \sst~\cite[Theorem
1]{composingSST}.
\begin{proposition}\label{prop:composition}
  Functions recognized by finiteness-preserving transducer semigroups are closed
  under composition.
\end{proposition}
\begin{proof}
  This is because finiteness-preserving functors are closed under composition,
  natural output functions are also closed under composition, and naturality
  means by definition that the output functions \enquote{commute} in a suitable
  sense with functors.\footnote{More precisely, consider the following diagram,
    where the upper path describes the composition of two functions recognized
    transducer semigroups $(\functor,\outfun)$ and $(\functor',\outfun')$,
    respectively:
    \[
      \begin{tikzcd}[ampersand replacement=\&, column sep=2cm]
        \Sigma^* 
        \ar[r,"h"]
        \& 
        \functor(\Gamma^*)
        \ar[r,"\outfun_{\Gamma^*}"]
        \ar[d,"\functor h'"]
        \&
        \Gamma^* \ar[d,"h'"]\\
        \&
        \functor\functor'(\Pi^*) \ar[r,"\outfun_{\functor'(\Pi^*)}"]
        \& 
        \functor'(\Pi^*)
        \ar[r,"\outfun'_{(\Pi^*)}"]
        \&
        \Pi^*
      \end{tikzcd}
    \]
    The rectangle in the middle commutes by naturality, and therefore the upper path is equal to the lower path. The latter describes a function recognized by $(\functor\functor', \outfun_{\functor'(-)} \circ \outfun')$.}
\end{proof}



 
\input{easy}

\input{polynomial-functors}

\subparagraph*{Proof of $(\ref{it:trans-semig-regular}) \Rightarrow (\ref{it:regular})$ in \Cref{thm:regular-functions}.}
We have now collected all necessary ingredients to prove this hard direction of the equivalence. Consider some transducer semigroup, with the functor being $\functor$, and fix a string-to-semigroup function $f : \Sigma^* \to A$ that decomposes as some homomorphism $h : \Sigma^* \to \functor A$ followed by the output function of type $\functor A \to A$. 
We will show that this function  is computed by some functorial \sst as in Definition~\ref{def:functorial-sst}.

For semigroups $A_1,\ldots,A_n$, define the \emph{vectorial output function} to be the 
function% of type 
\begin{align*}
\qquad\functor A_1 \times \cdots \times \functor A_n \longrightarrow A_1 \oplus \cdots \oplus A_n
\end{align*}
that is obtained by composing the three functions described below
\[
\begin{tikzcd}
\functor A_1 \times \cdots \times \functor A_n
\ar[d,"\functor(\text{co-projection}) \times \cdots \times \functor(\text{co-projection})"]
\\
\functor(A_1 \oplus \cdots \oplus A_n)
\times
\cdots
\times 
\functor(A_1 \oplus \cdots \oplus A_n)
\ar[d,"\text{semigroup operation}"]
\\
\functor(A_1 \oplus \cdots \oplus A_n)
\ar[d, "\text{output mechanism for $A_1 \oplus \cdots \oplus A_n$}"]\\ 
A_1 \oplus \cdots \oplus A_n.
\end{tikzcd}
\]

    To illustrate the definitions in this section, we use a running example with the transducer semigroup  from \Cref{ex:duplicator} for the duplicating function. The functor is the identity $\functor A = A$, and the output mechanism is $a \mapsto aa$. The duplicating function on $\set{a,b}^*$ is obtained by composing the identity homomorphism on $\set{a,b}^* = 
\functor(\set{a,b}^*)$
    with the output function.
    Here is an example of  the vectorial output function, applied to $A_1=1$ and $A_2=\set{a,b}^*$:
\begin{align*}
    (1,abbb) \in \functor 1 \times \functor \set{a,b}^* \qquad \mapsto \qquad 
\red{\boxed{1}}\  \boxed{abbb} \ \red{\boxed{1}} \  \boxed{abbb} \in 1 \oplus \set{a,b}^*.
\end{align*}
The  vectorial output function is natural in all of its arguments, which means that  
\[
\begin{tikzcd}
    [column sep=4cm]
\functor A_1 \times \cdots \times \functor A_n
\ar[r,"\text{vectorial output function}"]
\ar[d,"\functor h_1 \times \cdots \times \functor h_n"']
&
A_1 \oplus \cdots \oplus A_n
\ar[d,"h_1 \oplus \cdots \oplus h_n"]
\\
\functor B_1 \times \cdots \times \functor B_n
\ar[r,"\text{vectorial output function}"]
&
B_1 \oplus \cdots \oplus B_n
\end{tikzcd}
\]
commutes
for all semigroup homomorphisms $h_1,\ldots,h_n$. This is because each of the three steps in the definition of the vectorial output function is itself a natural transformation, and natural transformations compose.  Naturality of the first two steps is easy to check, while for the last step we use the assumption that the (non-vectorial) output function is natural.
% In other words, the factorized output function is a natural 
% transformation of type 
% \[\begin{tikzcd}
%     [column sep=1cm]
%     {\text{Semigroups}^n} && {\text{Sets}}
%     \arrow[""{name=0, anchor=center}, "{(A_1,\ldots,A_n)} \mapsto \text{underlying set of } \functor A_1 \times \cdots \times \functor A_n", curve={height=-18pt}, from=1-1, to=1-3]
%     \arrow[""{name=1, anchor=center, inner sep=0}, "{(A_1,\ldots,A_n)} \mapsto \text{underlying set of } A_1 \oplus \cdots \oplus A_n"', curve={height=18pt}, from=1-1, to=1-3]
%     \arrow[ shorten <=5pt, shorten >=5pt, Rightarrow, from=0, to=1]
% \end{tikzcd}\]



% By abuse of notation, we allow some -- but not all -- of the arguments in the factorized output to be empty; in this case the empty arguments are ignored, but the output type is still a co-product of $n$ semigroups. For example, if the input to the factorized output function is 
% \begin{align*}
% (1, \varepsilon) \in 1 \oplus \set{a,b}^+
% \end{align*}
% then the factorized  output is  
% \begin{align*}
% 1 1     \in 1 \oplus \set{a,b}^+.
% \end{align*}

Let us return to our string-to-semigroup function $f : \Sigma^* \to A$ in the assumption of the hard implication from Theorem~\ref{thm:regular-functions}.
Using the vectorial output mechanism, we will be able to track the origins in the output of the function $f$, with respect to some partition of the input string into several nonempty parts.
For  strings $w_1,\ldots,w_n \in \Sigma^*$, define the corresponding \emph{factorized output}, denoted by 
\begin{align*}
\tuple{w_1| \cdots | w_n} \in \myunderbrace{A \oplus \cdots \oplus A}{$n$ times},
\end{align*}
to be the result of first applying the semigroup homomorphism $h : \Sigma^* \to \functor A$ to all the strings, then applying the factorized output function, and finally removing the elements of the output co-product that correspond to input coordinates $i \in \set{1,\ldots,n}$ in which the string $w_i$ was the empty string $\varepsilon$.
\tito{wait, why perform this removal}
\tito{mention origin semantics~\cite{bojanczykTransducersOriginInformation2014}
  (see also~\cite[Section~5]{MuschollPuppis})
  as inspiration}
Here is the factorized output illustrated in our running example:\begin{align*}
        \tuple{\red{abbbbb} | \varepsilon | \blue{bbabaaa}} =  
        \red{\boxed{abbbbb}} \ 
        \blue{\boxed{bbabaaa}} \ 
        \red{\boxed{abbbbb}} \ 
        \blue{\boxed{bbabaaa}} \in \red{\set{a,b}^*} \oplus \set{a,b}^*  \oplus \blue{\set{a,b}^*}.
        \end{align*}
    Here, we use colours to distinguish which of the three parts of the input is used; the empty middle part has black colour which is not used in the output. As the above example shows, the factorized output tells us which parts of the output string come from which of the three parts in the input string.


We also use a similar notation but with some input strings underlined, e.g.~the input could be $\tuple{\red{\underline{abbbbb}} | \varepsilon | \blue{bbabaaa}}$ with an underline for the first red part. In the underlined case, before applying the vectorial output function, we apply $h$ to the non-underlined strings and
% \[
% \begin{tikzcd}
% \Sigma^*
% \ar[r,"h"]
% &
% \functor A 
% \ar[r,"\functor !"]
% &
% \functor 1.
% \end{tikzcd}
% \]
$(\functor! \circ h) \colon \Sigma^* \to \functor1$
to the underlined strings. (As before, the empty input strings are removed from the output.)    In our running example, we have
    \begin{align*}
        \tuple{\red{\underline{abbbbb}} | \varepsilon | \blue{bbabaaa}} =  
        \red{\boxed{1}} \ 
        \blue{\boxed{bbabaaa}} \ 
        \red{\boxed{1}} \ 
        \blue{\boxed{bbabaaa}}.
        \end{align*}



The following lemma uses the ingredients described in this section to define what is essentially the register update function in a streaming string transducer recognizing our function $f$.  As discussed earlier in this section, we consider functors such as $A \oplus 1$ and $1 \oplus A \oplus 1$ as polynomial semigroup-to-set functors, which enables us to talk about natural and copyless functions that operate on them.
\begin{lemma}\label{lem:compute-next-configuration}
    There is a {copyless} natural function
    \begin{align*}
    \delta\colon (A \oplus 1) \times (1 \oplus A \oplus 1) \to A \oplus 1
    \end{align*} 
    such that for every pair of strings $w,v \in \Sigma^*$ and every letter $a \in \Sigma$, one obtains $\tuple{wa|\underline v}$ by applying $\delta$ to the pair  consisting of  $\tuple{w|\underline {av}}$ and $\tuple{\underline w | a|\underline v}$.
    \end{lemma}
\tito{mention computability by rat fun -> use finiteness}
    Using the above lemma, one can define a functorial streaming string transducer, using finite polynomial functors $\functorr A \subset A \oplus 1$ (note that $A \mapsto A \oplus 1$ is not finite!) and $\functors A \subset 1 \oplus A \oplus 1$, that computes the function $f$ -- thus completing the proof of Theorem~\ref{thm:regular-functions}. The idea is that the transducer maintains the following invariant: after processing the first $i$ letters in an input string $a_1 \cdots a_n$, the configuration of the transducer is the factorized output $\tuple{a_1 \cdots a_i | \underline{a_{i+1} \cdots a_n}}$. After processing all input letters, the configuration stores the output string. The details are in the appendix. It remains to prove the lemma, which is done using the operations on coproducts described earlier in this section. 
    \tito{I'm a bit bothered by the fact that the single place where the finiteness-preserving hypothesis is used does not appear in the main text}

    \begin{proof}[Proof of \Cref{lem:compute-next-configuration}]
    We use the following claim, which is proved using naturality of the output mechanism (as detailed in the appendix).
    \begin{claim}\label{claim:merge-factorized-output}
        $\tuple{wa|\underline v}$ is obtained from $\tuple{w|a|\underline v}$ by merging the first two parts.
    \end{claim}
    % \begin{proof}[Proof sketch]
    %     % The following diagram commutes 
    %     % \[
    %     % \begin{tikzcd}
    %     %     [column sep=3cm]
    %     % \Sigma^* \times \Sigma \times \Sigma^* 
    %     % \ar[r,"{(w,a,v) \mapsto \tuple{w|a|\underline v}}"]
    %     % \ar[d,"{(w,a,v) \mapsto (wa,v)}"']
    %     % &
    %     % A \oplus A \oplus 1
    %     % \ar[d,"\text{merge first two coordinates}"]
    %     % \\
    %     % \Sigma^+ \times \Sigma^* 
    %     % \ar[r,"{(wa,v) \mapsto \tuple{wa|\underline v}}"']
    %     % &
    %     % A  \oplus 1
    %     % \end{tikzcd}
    %     % \]
    %  Using naturality of the output mechanism, and $\outfun$ and the fact that  both $h$ and merging the first two \enquote{copies of $A$} in $A \oplus A \oplus 1$ (by copairing coprojections) are homomorphisms.
    % \end{proof}

    Since merging the first two parts is a copyless natural function,  the above claim shows that  the factorized output $\tuple{wa|\underline v}$ is obtained from $\tuple{w|a|\underline v}$ by a copyless natural function. To complete the proof of the lemma, we will show that latter value $\tuple{w|a|\underline v}$  can also be obtained by applying some copyless natural function to the pair consisting of  $\tuple{wa|\underline v}$  and $\tuple{\underline w|a|\underline v}$. This will be done using (an extension of) Lemma~\ref{lem:views}.
    Consider the function of type 
    \begin{align*}
        A \oplus A \oplus 1 \to \myunderbrace{(1 \oplus A)}{first\\ view} \times
       \myunderbrace{(1 \oplus A)}{second\\ view} \times
       \myunderbrace{(1 \oplus 1)}{third\\ view} \times 
       \myunderbrace{(1 \oplus 1 \oplus 1)}{shape},
       \end{align*}
    which is the injective function from Lemma~\ref{lem:views} in the special case of the coproduct $A \oplus A \oplus 1$. We use the name \emph{deconstruction} for this function. By the same proof as in  Lemma~\ref{lem:views}, this function is not only injective, but it also has a one-sided inverse, i.e~a function of type\footnote{One might expect this function to be partial, since it is the inverse of a function that is injective but not surjective. However, every input that is not in the image of the deconstruction can be mapped to the default value $1 \in A \oplus A \oplus 1$.}
    \begin{align*}
(1 \oplus A) \times (1 \oplus A) \times (1 \oplus 1) \times (1 \oplus 1 \oplus 1) \to A \oplus A \oplus 1,
    \end{align*}
   which we call \emph{reconstruction},  such that deconstruction followed by reconstruction is the identity on $A \oplus A \oplus 1$. Furthermore,  reconstruction is natural in $A$ and copyless.

   By the above observations, one can obtain the factorized output $\tuple{w|a|\underline v}$ by applying reconstruction to the  following four items (the equalities below are proved using  Claim~\ref{claim:merge-factorized-output}):
     \begin{enumerate}
        \item \label{it:first-view}First view of $\tuple{w|a|\underline v}$, which is equal to $\tuple{w|\underline {av}}$.
        \item  \label{it:second-view} Second view of $\tuple{w|a|\underline v}$, which is obtained by merging the first and third parts in $\tuple{\underline w|a|\underline v}$.
        \item \label{it:third-view}   Third view of $\tuple{w|a|\underline v}$, which is equal to $\tuple{\underline {wa}|\underline{v}}$.
        \item   \label{it:shape} Shape of~$\tuple{w|a|\underline v}$, which is equal to $\tuple{\underline w|\underline a| \underline v}$.
     \end{enumerate}
     To complete the proof of the lemma, it remains to justify that the last three items can be obtained from $\tuple{\underline w|a|\underline v}$ by applying some copyless natural function. Each item is obtained separately by applying a natural function. Furthermore, the second item is obtained in a copyless way, while the last two items do not use $A$ at all, and therefore they are obtained in a copyless way for trivial reasons, even when combined with the second item.
\end{proof}


% \begin{lemma}
%     There is a letter-to-letter rational function 
%     \begin{align*}
%     \rho : \Sigma^* \to (1 \oplus A \oplus 1)^*
%     \end{align*}
%     such that for every input string $a_1 \cdots a_n$, the $i$-th letter of the output is 
%     \begin{align*}
%         \tuple{\underline{a_1 \cdots a_{i-1}}|a_i| \underline{ a_{i+1} \cdots a_n}} \in 1 \oplus A \oplus 1.
%     \end{align*}
% \end{lemma}
% \begin{proof}
%     For an interval $\set{i,\ldots,j}\subseteq \set{1,\ldots,n}$, we define 
%     The $i$-th letter produced by the rational function is 
%     \begin{align*}
%         \tuple{\underline{a_1 \cdots a_{i-1}}|a_i| \underline{ a_{i+1} \cdots a_n}} \in 1 \oplus A \oplus 1.
%     \end{align*}
% We begin by showing that these letters can indeed be produced by a letter-to-letter rational function. To see this, we observe that the above depends only on the letter $a_i$, as well as the images of the strings $a_1 \cdots a_{i-1}$ and $a_{i+1} \cdots a_n$ under the semigroup homomorphism
% \begin{align*}
% \functor ! : \Sigma^* \to \functor 1.
% \end{align*}
% Since the target of this homomorphism is a finite semigroup, by the assumption that the functor is finiteness preserving, it follows that the 
% \end{proof}
