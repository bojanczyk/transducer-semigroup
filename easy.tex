\subsection{Defininition of streaming string transducers}
\label{sec:sst-definition}
In this section, we formally describe the regular functions, using a model based on streaming string transducers (\sst).  This model, like our proof of Theorem~\ref{thm:regular-functions}, covers a slightly more general case, namely string-to-semigroup functions instead of only string-to-string functions. These are functions of type $\Sigma^* \to A$ where $\Sigma$ is a finite alphabet and $A$ is an arbitrary semigroup.  The purpose of this generalization is to make notation more transparent, since the fact that the output semigroup consists of strings will not play any role in our proof.

% The model is a minor variation on streaming string transducers, which use registers to store elements of the output semigroup.
The model uses registers to store elements of the output semigroup. We begin by describing notation for registers and their updates. Suppose that $R$ is a finite set of \emph{register names}, and $A$ is a semigroup called the \emph{output semigroup}. We consider two sets 
\begin{align*}
\hspace{2cm}
    \myunderbrace{R \to A}{the set of \emph{register valuations}} 
    \hspace{4cm}
    \myunderbrace{R \to (A+R)^+.}{the set of \emph{register updates}}
\end{align*}
Below we show two examples of register updates, using two registers $X,Y$ and the semigroup $A = a^*$.  The updates are presented as assignments, with the right-hand sides being the values in $(A+R)^+$.
\begin{align*}
    \myunderbrace{
    \begin{array}{l}
        X:= aYaXaaa\\
    Y:= XaaXaa
    \end{array}
    }{copyful}
    \qquad 
    \myunderbrace{
    \begin{array}{l}
        X:= aaYaaXaaa\\
    Y:= aaa
    \end{array}
    }{copyless}
    \end{align*}
The crucial property is being copyless -- a register update is called copyless if every register name appears in at most one right-hand side of the update, and in that right-hand side it appears at most once. 
The main operation on these sets is \emph{application}: a register update can be applied to a register valuation, giving a new register valuation. 


In our model of streaming string tranducers, the registers will be updated by a stream of register updates that is produced by a {rational function}, defined as follows.  Intuitively speaking, a rational function corresponds to an automaton that produces one output letter for each input position, with the output letter depending on regular properties of the input position within the input string. More formally, a \emph{rational function} is defined to be a length-preserving\footnote{Often in the literature, rational functions are not required to be length-preserving, see e.g.~\cite[p.~525]{sakarovitch2009elements}, but in this paper, we only need the length-preserving case.} string-to-string function such that for some recognizable function 
\begin{align*}
 f\colon (\set{\text{current, not current}} \times \text{(input alphabet)})^+ \to \text{output alphabet},
\end{align*}
for every input string the  $i$-th output letter is obtained by applying the function
to the string that is obtained from the input string by setting the first coordinate to ``current'' for the $i$-th position, and ``not current'' for the remaining positions.  

Having defined register updates and rational functions, we are ready to define the variant of streaming string transducers used in this paper.



\begin{definition}\label{def:usual-sst}
    The syntax of a streaming string transducer is given by:
\begin{itemize}
    \item A finite \emph{input alphabet} $\Sigma$ and an \emph{output semigroup $A$}.
    \item A finite set $R$ of \emph{register names}. All register valuations and updates below use $R$ and $A$.
    \item A designated \emph{initial register valuation}, and a designated \emph{final register}.
    \item An update oracle, which is a rational function of type 
    \begin{align*}
    \Sigma^* \to (\text{copyless register updates})^*.
    \end{align*}
\end{itemize}
\end{definition}

The semantics of the transducer is a function of type $\Sigma^* \to A$ defined as follows. When given an input string, the transducer begins in the designated initial register valuation. Next, it applies all updates produced by the update oracle, in left-to-right order. Finally, the output of the transducer is obtained by returning the semigroup element stored in the designated final register. 

In a rational function, the label of the $i$-th output position is allowed to depend on letters of the input string that are on both sides of the $i$-th input position; this corresponds to regular lookaround in a streaming string transducer. Therefore, the model described above is easily seen to be equivalent to copyless \sst{}s with regular lookaround, which are one of the equivalent models defining the regular string-to-string functions, see~\cite[Section~IV.C]{AlurFT12}.
\tito{Even though it's for $\omega$-words I prefer citing published papers to the Toolbox}

\subsection{From a regular function to a transducer semigroup}
\label{sec:easy}

Having defined the transducer model, we prove the easy implication  in  \Cref{thm:regular-functions}. 

Suppose that a string-to-semigroup function $f\colon \Sigma^* \to A$ is computed by some streaming string transducer. In the proof below, when referring to register valuations and register updates, we refer to those that use the registers and output semigroup of the fixed transducer. We say that a register update is in \emph{normal form} if, in every right-hand side, one cannot find two consecutive letters from the semigroup $A$.
\tito{looks like the coproduct $A \oplus \bigoplus_{X\in R} \{X\}^+$ --- should we mention that?}
Here is an example, which uses three registers $X,Y,Z$ and the semigroup $A = (\set{0,1}, \cdot)$:
\begin{align*}
\myunderbrace{
\begin{array}{l}
    X:= 01Y1111X111\\
Y:= 01011
\end{array}
}{not in normal form}
\qquad 
\myunderbrace{
\begin{array}{l}
    X:= 0Y1X1\\
Y:= 0
\end{array}
}{in normal form}
\end{align*}

Every register update can be normalized, i.e.~converted into one that is in normal form, by using the semigroup operation to merge consecutive elements of the output semigroup in the right-hand sides. The  register updates before and after normalization act in the same way on register valuations.   If a register update is copyless and in normal form, then the combined length of all right hand sides is at most three times the number of registers. Therefore, if a semigroup is finite, then the set of copyless register updates in normal form, call it $\functors A$,  is also finite. (This would not be true for copyful register updates.) The set $\functors A$ of register updates in normal form can be equipped with a composition operation 
\begin{align*}
    u_1,u_2 \in \functors A  \quad \mapsto \quad u_1u_2 \in \functors A,
    \end{align*}
which is defined in the same way as applying a register update to a register valuation, except that we normalize at the end. This composition operation is associative, and  compatible with applying register updates to register valuations, in the sense that $(vu_1)u_2 = v(u_1u_2)$ holds for every register valuation $v$ and register updates $u_1$ and $u_2$. Therefore, $A \mapsto \functors A$ is a finiteness-preserving semigroup functor. (With the natural extension to morphisms, where the homomorphism is applied to every semigroup element in a right-hand side.) 

The functor $\functors$ described above is not the functor that will be used in the transducer semigroup that we will define to prove the easy implication in Theorem~\ref{thm:regular-functions}. That functor will also take into account the update oracle. Consider the update oracle in the streaming string transducer from the assumption of the easy implication. Since the update oracle is a rational function, there is a semigroup homomorphism
\begin{align*}
h : (\set{\text{current, not current}} \times \text{(input alphabet)})^* \to B,
\end{align*}
into a finite semigroup such that the $i$-th letter produced by the update oracle depends only on the result of applying this homomorphism to the string obtained from the input in the way that was described in the definition of rational functions. Without loss of generality, we assume that $B$ is a monoid. The functor $\functor$ is defined as follows. If the input semigroup is $A$, then the underlying set of the output semigroup $\functor A$ is 
\begin{align*}
     B \quad \times \quad \myunderbrace{(B \times B) \to \functors A}{functions of this kind\\ are  called \emph{conditional} \\\emph{register updates}} 
\quad \blue{\times \quad \myunderbrace{R \to A}{register\\ valuations}.}
\end{align*}
\tito{This is clearly a composition construction. Since we can already compose by abstract nonsense it might look less complex to decompose into: (1) \sst{}s whose update depends only on the current input letter can be translated to $\functors A \times (R \to A)$; (2) rational functions can be translated to $B \times ((B\times B) \to A)$}
The semigroup operation is defined as follows. On the third coordinate (in \blue{blue}), we use the trivial left zero semigroup structure. On the first two coordinates (in black), the semigroup structure is defined\footnote{This definition coincides with the two-sided semidirect product of monoids from~\cite[Section 6]{rhodes1989kernel}, when applied to the monoids $B$ and $\functors A$.} so that the product of two pairs $(b_1,\varphi_1)$ and $(b_2,\varphi_2)$ is  the pair consisting of $b_1 b_2$ and the function  
\begin{align*}
(c_1,c_2)  \mapsto   \varphi_1(b_1,c_2b_2) \cdot \varphi_2(b_1c_1,b_2).
\end{align*}
The construction $\functor$ is extended to morphisms in the same way as $\functors$. 

The output mechanism in the transducer semigroup is defined as follows.  When given $(b,\varphi,v) \in \functor A$, the output function returns the element of the semigroup $A$ that is obtained as follows:  (1) apply  $\varphi$ to the pair consisting of the neutral elements in the monoid $B$, yielding a register update in $\functors A$; then (2) apply this  register update to the register valuation $v$,  yielding some new register valuation; and then (3) from the resulting register valuation, return the semigroup element stored in the distinguished output register.  Checking the naturality condition is left to the reader.

Using the transducer semigroup defined above, we can recognize the function  computed by our streaming string transducer. 
% The corresponding homomorphism takes an input letter $a \in \Sigma$ to the function that takes a state $q$ and returns the corresponding new state and register update from the transducer. 