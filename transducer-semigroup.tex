\section{Transducer semigroups and warm-up theorems}\label{sec:warm-up}

In this section, we define the model that is introduced in this paper, namely \kl{transducer semigroups}. The purpose of this model is to recognize \emph{string-to-string} functions, which are defined to be functions of type $\Sigma^* \to \Gamma^*$, for some finite alphabets $\Sigma$ and $\Gamma$. Some results will work in the slightly more general case where the domain or codomain is a more general semigroup, but we focus on the string-to-string case for the sake of concreteness.

The model is defined using terminology based on category theory. However, we do not assume that the reader has a background in category theory, beyond the two most basic notions of category and functor. Recall that a \emph{category} consists of objects with morphisms between them, such that the morphisms can be composed and each object has an identity morphism to itself. In this paper, we will be working mainly with two categories:
\begin{description}
 \item[Sets.] The objects are sets, the morphisms are functions between them.
 \item[Semigroups.] The objects are semigroups, the morphisms are semigroup homomorphisms.
\end{description}
To transform categories, we use {functors}.
Recall that a \emph{functor} between two categories consists of two maps: one that assigns to each object $A$ in the source category an object in the target category, and another one that assigns to each morphism $f\colon A \to B$ a morphism $\functor f\colon \functor A \to \functor B$. These maps need to be consistent with composition of morphisms, and the identity must go to the identity.
\begin{example}\label{ex:forgetful}
    The \intro{forgetful functor} from the category of semigroups to the category of sets maps a semigroup to its underlying set, and a semigroup homomorphism to the corresponding function on sets. It is an example of a semigroup-to-set functor.
\end{example}
 \begin{example}\label{ex:functors}
 These constructions can be seen as semigroup-to-semigroup functors:
 \begin{description}
 \item[Tuples.] This functor maps a semigroup $A$ to its square $A \times A$, with the semigroup operation defined coordinate-wise. The functor extends to morphisms in the expected way. This functor also makes sense for higher powers, including infinite powers, such as $A^\omega$.
 \item[Opposite.] This functor maps a semigroup $A$ to the semigroup where the underlying set is the same, but multiplication is reversed, i.e.~the product of $a$ and $b$ in the new semigroup is the product $b$ and $a$ in the old semigroup. Morphisms are not changed by the functor: they retain the homomorphism property despite the change in the multiplication operation.
 \item[Lists.] This functor maps a semigroup $A$ to the free monoid $A^*$ that consists of lists (or strings) over the alphabet $A$ equipped with concatenation. On morphisms, the functor is defined element-wise (or letter-wise). A similar construction would make sense as a set-to-semigroup functor.
 \item[Non-empty lists.] A variant of the previous example, which sends a
   semigroup $A$ to the free semigroup $A^+$ that consists of non-empty lists of
   elements in $A$.
 \item[Powerset.] This (covariant) powerset functor maps a semigroup $A$ to the powerset semigroup $\powerset A$, whose underlying set is the family of all subsets of $A$, endowed with the operation
 \begin{align*}
 (A_1,A_2) \quad \mapsto \quad \left\{a_1 a_2 \mid a_1 \in A_1\ \text{and}\ a_2 \in A_2\right\}.
 \end{align*}
 \end{description}
 \end{example}

\noindent
 We now present the central definition of this paper. 

\newcommand{\emptytester}{2}
\begin{definition}[Transducer semigroup]\label{def:transducer-semigroup}
 A \intro{transducer semigroup} consists of a semigroup-to-semigroup functor $\functor$, together with an \intro{output mechanism}, which associates to each semigroup $A$ a function of type $\functor A \to A$, called the \emph{output function for $A$}. The output function does not need to be a semigroup homomorphism. The output mechanism is required to be \intro{natural}, which means that the diagram
below commutes for every homomorphism $h\colon A \to B$. 
 \[
 \begin{tikzcd}
 \functor A 
 \ar[r,"\functor h"]
 \ar[d,"\text{output function for $A$}"']
 &
 \functor B
 \ar[d,"\text{output function for $B$}"]
 \\
 A
 \ar[r,"h"']
 &
 B
 \end{tikzcd}
 \]

\end{definition}
In the language of category theory, the naturality condition from the above definition says that the output mechanism is a \emph{natural transformation} of type 
\[\begin{tikzcd}
 [column sep=2.3cm]
 {\text{Semigroups}} && {\text{Sets}}
 \arrow[""{name=0, anchor=center}, "\text{[\kl{forgetful functor}]} \circ \functor", curve={height=-18pt}, from=1-1, to=1-3]
 \arrow[""{name=1, anchor=center, inner sep=0}, "\text{\kl{forgetful functor} (\Cref{ex:forgetful})}"', curve={height=18pt}, from=1-1, to=1-3]
 \arrow[ shorten <=5pt, shorten >=5pt, Rightarrow, from=0, to=1].
\end{tikzcd}\]


The purpose of \kl{transducer semigroups} is to define functions between semigroups, as explained in the following definition. 
\begin{definition}\label{def:reco-trans}
 We say that a function $f\colon A \to B$ between semigroups, not necessarily a homomorphism, is \emph{recognized} by a \kl{transducer semigroup} if it can be decomposed as
 \[
 \begin{tikzcd}
 [column sep=1.6cm]
 A 
 \ar[r,"h"]
 &
 \functor B
 \ar[rr,"\text{output function for $B$}"]
 &&
 B
 \end{tikzcd}
 \quad
 \text{for some semigroup homomorphism}\ h.
 \]
\end{definition}
\AP We are mainly interested in the special case of \kl{transducer semigroups} where the functor $\functor$ is \intro{finiteness-preserving}, i.e.~it maps finite semigroups to finite semigroups. This special case will correspond to the \kl{regular string-to-string functions}. Some minor results about the general case, when $\functor$ is not necessarily finiteness-preserving, are presented in Section~\ref{sec:two-simple}.

After a few examples, we give some intuitions about this definition in \Cref{rem:parametricity}.

\begin{example}
 Consider the \kl{transducer semigroup} in which the functor is the identity, and the \kl{output mechanism} is also the identity. The functions of type $A \to B$ that are recognized by this transducer semigroup are exactly the semigroup homomorphisms from $A$ to $B$.
\end{example}

\begin{example}\label{ex:reverse-duplicate}
  Consider the \kl{transducer semigroup} in which
  \begin{itemize}
  \item the functor is the \enquote{opposite semigroup} functor from
    \Cref{ex:functors};
  \item the output function maps $a\in\functor A$, seen as an element in $A$, to
    $aa \in A$.
  \end{itemize}
  The functions of type $A \to B$ that are recognized by this \kl{transducer semigroup} are exactly those of the form $a \mapsto h(a)h(a)$ where $h\colon A
  \to B$ is some \enquote{anti-homomorphism}, i.e.\ satisfies
  $h(a_1a_2)=h(a_2)h(a_1)$ for all $a_1,a_2\in A$. In particular, if $h$ is the
  string reversal function $\mathtt{rev}$ on the free monoid $\Sigma^*$, which
  is also a semigroup, then we get the \enquote{reverse then duplicate} function
  that maps a string $w$ over the alphabet $\Sigma$ to $\mathtt{rev}(w) \cdot
  \mathtt{rev}(w)$.
\end{example}

\begin{example}\label{ex:squaring}
  We present here a \kl{transducer semigroup} that recognizes the squaring function
  $w \in \Sigma^* \mapsto w^{|w|} \in \Sigma^*$ (illustrated by $\mathtt{123
    \mapsto 123123123}$) for any alphabet $\Sigma$.
  
  The functor maps $A$ to $A \times \mathbb{N}$, with the semigroup structure
  defined componentwise ($\mathbb{N} = \{0,1,\dots\}$ is equipped with
  addition), and making the morphisms act on the left component. 
  The output mechanism $A\times\mathbb{N} \to A$ is defined below:
  \begin{align*}
    \text{for}\ n \geq 1,\; (a,n) \mapsto a^n \qquad\qquad \myunderbrace{(a,0) \mapsto a}{\qquad\qquad\qquad we handle this case separately because $a^0$ does not make sense in an arbitrary semigroup}
  \end{align*}
\end{example}

\begin{remark}\label{rem:parametricity}
  Let $(\functor,\outfun)$ be a transducer semigroup. For a semigroup $S$, we
  may often think of an element of $\functor S$ as a data structure that
  contains elements of $S$ (such as a pair or a list, cf.~\Cref{ex:functors}).
  Then naturality of the output mechanism expresses that, being defined
  \enquote{uniformly in $S$}, it is not allowed to \enquote{look
    inside}\footnote{This is similar to the \enquote{generic} or
    \enquote{polymorphic} function definitions supported by many statically
    typed programming languages. The corresponding notion in type theory is
    \emph{parametric polymorphism}, and it is closely related to naturality, see
    the introduction to~\cite{Parametricity}.} those elements of $S$. In other
  words, the control flow may depend only on the part that is
  \enquote{independent of $S$} -- and the condition that $\functor$ is
  \kl{finiteness preserving} somehow expresses that this part of $\functor S$ is
  finite.
\end{remark}

\begin{remark}
  \Cref{def:reco-trans} discusses functions between arbitrary semigroups, but we will
  mainly care about string-to-string functions $f\colon \Sigma^* \to \Gamma^*$,
  i.e.~the special case when both the input and output semigroups are finitely
  generated free monoids. Although the case that we care about involves monoids,
  which are a special case of semigroups, the use of a semigroup homomorphism that
  is not necessarily a monoid homomorphism is required to recognize functions such
  that $f(\varepsilon)\neq\varepsilon$. Furthermore, it will be useful in the
  proofs to work in the category of semigroups, rather than the category of monoids.
\end{remark}

\subsection{Two simple characterizations}
\label{sec:two-simple}

We begin with two simple theorems, which use transducer semigroups to capture two classes of string-to-string functions: all functions (Theorem~\ref{thm:all-functions}) and functions that reflect \kl{recognizability} (Theorem~\ref{thm:reco-reflecting-functions}).
%These two theorems have simple proofs.
The main contribution of this paper, presented in Section~\ref{sec:reg-char},
characterizes the regular functions using a stronger restriction than those
considered here.

\subparagraph{All functions.} The first theorem concerns transducer semigroups without any restrictions.

\begin{theorem}\label{thm:all-functions} 
 Every string-to-string function is recognized by a \kl{transducer semigroup}.
\end{theorem}
\begin{proof}
 We prove a slightly stronger result: for any semigroup $A$, there exists a transducer semigroup that recognizes all functions from $A$ to other semigroups. The functor is 
 \begin{align*}
 \functor B = A \times \text{(set of all functions of type $A \to B$, not necessarily recognizable)}.
 \end{align*}
 \AP The semigroup operation in $\functor B$ is defined as follows: on the first coordinate, we inherit the semigroup operation from $A$, while on the second coordinate, we use the trivial \intro{left zero} semigroup structure, in which  the product of two functions is simply the first one (this is a trivial way of equipping every set with a semigroup structure). The functor is defined on morphisms
as in the tuple construction from Example~\ref{ex:functors}: the first coordinate, corresponding to~$A$, is not changed, and the second coordinate, corresponding to the set of functions, is transformed coordinate-wise, when viewed as a tuple indexed by~$A$. This is easily seen to be a functor. The output mechanism, which is easily seen to be natural, is function application i.e.~$(a,f) \mapsto f(a)$.
Every function $f\colon A \to B$ is recognized by this transducer semigroup, with the appropriate homomorphism is~$a \in A \mapsto (a,f)$.
\end{proof}

\subparagraph{Recognizability reflecting functions.} We now characterize
functions with the property that inverse images of \kl{recognizable languages} are
also \kl{recognizable}. We use a slightly more general setup, where instead of
languages we use functions into arbitrary sets (languages can be seen as the
case of functions into $\set{\text{yes},\text{no}}$).

\begin{definition}
  We say that a function from a semigroup $A$ to some set $X$ is
  \intro{recognizable} if it factors through some semigroup homomorphism from $A$
  to a \emph{finite} semigroup.
\end{definition}
In the rest of the paper, we shall sometimes
speak of \kl{recognizable functions} with infinite codomain, but note that the
range of a \kl{recognizable function} is always finite.

\AP A function $f\colon B \to A$ between semigroups, not necessarily a semigroup
homomorphism, is called \intro{recognizability reflecting} if for every
\kl{recognizable function} $g\colon A \to X$, the composition $g \circ f$ is
\kl{recognizable}.

\begin{example}
  Consider the semigroup $(\Nat, +)$ of natural numbers with addition, which is isomorphic to the free monoid $a^*$. In this semigroup, the recognizable functions are ultimately periodic colourings of numbers. A corollary is that every recognizable function gives the same answer to all factorials $\set{1!,2!,\ldots}$, with finitely many exceptions. Take any function $f\colon \Nat \to \Nat$ such that (a) every output number arises from at most finitely many input numbers; (b) every output number is a factorial. The composition of $f$ with any recognizable function will give the same answer to all numbers with finitely many exceptions, thus being also recognizable.
\end{example}

In the above example, a function with conditions (a) and (b) can be chosen in uncountably many ways, even if we require that it has linear growth.
Therefore, there are too many \kl{recognizability reflecting} functions (even
just from $\{a\}^*$ to itself) to
allow a machine model, or some other effective syntax. The following result
gives a non-effective syntax.

\begin{theorem}\label{thm:reco-reflecting-functions} The following conditions are equivalent for a string-to-string function:
 \begin{enumerate}
 \item \label{it:reco-refl} it is \kl{recognizability reflecting}.
 \item \label{it:trans-semig-reco}it is recognized by a transducer semigroup such that for every finite semigroup $A$, the corresponding output function of type 
 $\functor A \to A$
 is \kl{recognizable}.
 \end{enumerate}
\end{theorem}
\begin{example}\label{ex:squaring-reco-refl}
  For any finite semigroup $A$, the map $(a,n) \in A \times
  (\mathbb{N}\setminus\{0\}) \mapsto a^n \in A$ is \kl{recognizable}. This is
  because, since $a^{|A|!}$ is idempotent for every $a\in A$, this map factors
  through a homomorphism into the semigroup $A \times
  ((\mathbb{N}\setminus\{0\})/\sim)$ where $\sim$ is the congruence of
  finite index
  \[ n \sim m ~~\iff~~ n = m ~~\lor~~ \big(n,m \geq |A|! ~\land~ n \equiv m \;\mathrm{mod}\; |A|!\big) \]
  Extending this slightly to handle the case $(a,0)\mapsto a$, one can show that the output mechanism $\outfun_A$ of \Cref{ex:squaring} is \kl{recognizable} whenever $A$ is finite. Therefore, the squaring function is \kl{recognizability reflecting}.
\end{example}
