\section{Last step in the proof of Theorem~\ref{thm:regular-functions}}
In this part of the appendix, we finish the proof of \Cref{thm:regular-functions}, by using \Cref{lem:compute-next-configuration} to define a functorial streaming string transducer to define the function $f : \Sigma^* \to A$ that is recognized by a transducer semigroup with a finiteness-preserving functor. 

Using \Cref{lem:compute-next-configuration}, we can design a device that  recognizes our desired function $w \mapsto \tuple{w}=f(w)$, and which is almost a functorial \sst as in Definition~\ref{def:functorial-sst}. We say ``almost'', because the device will use register and update functors that are  infinite polynomial functors; this construction will be later improved so that it becomes finite.  The register and update functors are the (infinite) polynomial functors
\begin{align*}
\functorr A  = 1 \oplus A \qquad \functors A = 1 \oplus A \oplus 1.
\end{align*}
As mentioned above, these are  not a finite polynomial functors; we will resolve this problem shortly.  
Beyond that, the construction is immediate. Consider an input string 
$a_1 \cdots a_n$. The device begins its computatin with the  initial register value 
\begin{align*}
    \tuple{\varepsilon | \underline{a_1 \cdots a_n}} \in A \oplus 1.
\end{align*}
This value does not depend on the input string, since it is always equal to the unique element of $1 \oplus A$ that does not use $A$. The rational function  in the transducer is defined so that the $i$-th lettter of its output string is 
\begin{align*}
\tuple{\underline{a_1 \cdots a_{i-1}}|a_i| \underline{a_{i+1} \cdots a_n}} \in 1 \oplus A \oplus 1
\end{align*}
We will explain shortly how these letters  can be computed by a rational function.
Thanks to Lemma~\ref{lem:compute-next-configuration}, after applying all the register updates produced by this rational function to the initial register valuation, the register valuation at the end is 
\begin{align*}
    \tuple{a_1 \cdots a_n | \varepsilon} \in A \oplus 1,
\end{align*}
which is the same as the output when viewed as an element of $A \oplus 1$, as required in Definition~\ref{def:functorial-sst}  for representing the output of a partial function.

We are left with proving that the update oracle is a rational letter-to-letter function, and resolving the issue that  the two functors $\functorr$ and $\functors$ are not finite polynomial functors.

To see why the update oracle is a rational letter-to-letter function, we observe that 
\begin{align*}
    \tuple{\underline{a_1 \cdots a_{i-1}}|a_i| \underline{a_{i+1} \cdots a_n}} \in 1 \oplus A \oplus 1
    \end{align*}
depends only the letter $a_i$, as well as the images of the words  $a_1 \cdots a_{i-1}$ and $a_{i+1} \cdots a_n$ under the semigroup homomorphism obtained by composing $h$ with 
$
\functor ! : \functor A \to \functor 1.
$
Since the target semigroup $\functor 1$  of this homomorphism is a finite, by the assumption that the functor is finiteness preserving, it follows that the  update oracle is a rational letter-to-letter function.

We now explain how to turn $\functorr$ and $\functors$ into finite polynomial functors. The key observation is  that not all of $1 \oplus A$ need be used for the register values, only a small part of it, and likewise for the update functor. More formally, 
consider the natural bijection
\begin{align*}
A \oplus 1  \quad \cong \quad 
\coprod_{q \in 1 \oplus 1}  A^{\dim q}
\end{align*}
that was discussed in Section~\ref{sec:coproducts-and-views}. If we apply this bijection to a factorized output $
\tuple{w|\underline {v}} \in A \oplus 1$, 
then the corresponding component will be $\tuple {\underline w | \underline v}$. Since the latter depends only  on $\underline w$ and $\underline v$, and these take values in the finite semigroup $\functor 1$, it follows that there are only finitely many components of $A \oplus 1$ that will be used to represent values from of the form $\tuple {w | \underline v}$. Therefore, instead of using $\functorr A$ to be all of $A \oplus 1$, we can restrict it to those finitely many components, giving thus a finite polynomial functor. The same argument applies to the update functor $\functors A$.