\section{Introduction}
\label{sec:intro}

This paper is about the regular string-to-string functions. This is a fundamental class of functions, which covers examples such as the string reversal function $123 \mapsto 321$ or duplication $123 \mapsto 123123$. Similarly to the class of regular languages, the class of regular functions has many equivalent descriptions, including deterministic two-way automata~\cite[Note~4]{shepherdson1959reduction}, copyless streaming string transducers (\sst)~\cite[Section~3]{alurExpressivenessStreamingString2010} (or the earlier and very similar single0use restricted macro tree transducers~\cite[Section~5]{MacroMSO}), \mso transductions~\cite[Theorem~13]{engelfrietMSODefinableString2001}, combinators~\cite[Section~2]{alur2014regular}, a functional programming language~\cite[Section~6]{bojanczykRegularFirstOrderList2018}, $\lambda$-calculus with linear types~\cite[Theorem~3]{LambdaTransducer} (see also~\cite[Claim~6.2]{IATLC} and~\cite[Theorem~1.2.3]{titoPhD}), decompositions \textit{Ã  la} Krohn--Rhodes~\cite[Theorem~18, item~4]{bojanczykstefanski2020}, etc.

The number of equivalent descriptions clearly indicates that, similarly to the class of regular languages, the class of regular functions is important and worth studying. However, from a mathematical point of view, a disappointing phenomenon is that each of the known descriptions uses syntax that is more complicated than one could wish for. For example, the definition of a two-way automaton requires a discussion of endmarkers and what happens when the automaton loops. In an \mso transduction, an unwiedly copying mechanism is necessary. In a streaming string transducer, one needs to be careful about bounding the copies among registers, and there are some delicate questions regarding lookahead. Each of the combinator calculi has a long list of combinators. Similar remarks apply to the other calculi. These complications are perhaps minor annoyances, and the corresponding models are undeniably useful. Nevertheless, it would be desirable to have a model with a short and abstract definition, similar to the definition of recognizability of regular languages by finite semigroups. Such a model  would give further evidence in favour of the accepted notion of regularity for string-to-string functions, and answer questions for the other models such as ``why not allow this or that feature to two-way automata?'', ``why not allow copying for streaming string transducers?'' or ``why not add this or that combinator?''.

This paper proposes such an abstract model.  We prove that the regular  string-to-string functions are exactly those that can be obtained by composing two functions
\[
\begin{tikzcd}
    \Sigma^* 
    \ar[r,"h"]
    & 
    \functor(\Gamma^*)
    \ar[r,"\outfun_{\Gamma^*}"]
    &
    \Gamma^*,
\end{tikzcd}
\]
where $\functor$ is a functor from the category of semigroups to itself that maps finite semigroups to finite semigroups, $h$~is a semigroup homomorphism, and the output function $\outfun_{\Gamma^*}$ is natural in the sense of natural transformations. We use the name \emph{transducer semigroup} for the model implicit in this description, i.e.~a semigroup-to-semigroup functor $\functor$ together with a natural transformation for producing outputs.  One of the surprising features of this model is the fact that linear growth of the output size, which is one of the salient features of the regular string-to-string functions, is not explicitly included in the model, but it is a provable consequence of it. 



